# -*- coding: utf-8 -*-
"""Стажировка

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CzKhZh8ikrmFkUgMXbAauqQ8fswkMsYg

# Зависимости
"""

import vk_api
from vk_api.execute import VkFunction

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
import matplotlib.dates as mdates
from itertools import combinations

import json
import time

#################################-----------------------------------------------------##################################
#################################################-----GLOBAL VARIABLES-----#################################################
#################################-----------------------------------------------------##################################

#ТОКЕН ВК - это мой, он сервисный
ACCESS_TOKEN = '315abab5315abab5315abab509312e0fa53315a315abab56ec54f60fee5a2380a857387'

#Текущая сессия
vk_session = vk_api.VkApi(token=ACCESS_TOKEN)
#Методы API теперь как обычные классы
vk = vk_session.get_api()

#ID групп, которые нужно анализировать
#Перед началом нужно этот список заполнить нужными ID, найти их необходимо будет вручную
#Чтобы делать запрос на поиск по группам к API - нужно будет поменять ключ на пользовательский
group_ids = []

#from google.colab import drive
#drive.mount('/content/drive')

#################################-----------------------------------------------------##################################
#################################################-----GETTING DATA-----#################################################
#################################-----------------------------------------------------##################################

def get_group_members(vk, group_id, fields = ('bdate', 'city', 'education', 'sex'), exec_count = 20000):
    '''Возвращает список всех подходящих участников группы.

    Аргументы: \n
        vk_api -- VK API, vk_api.VkApi().getApi(), необходимый параметр\n
        group_id -- ID рассматриваемой группы, обязательный параметр\n
        fields -- дополнительные поля для включения в ответ, (по умолчанию: 'bdate', 'city', 'education', 'sex')\n
        exec_count -- количество участников, запрашиваемых за один раз. НЕ БОЛЬШЕ 25000 (по умолчанию 20000)

    Возвращаемое значение:\n
        Список объектов типа "пользователь", смотреть в документации к API

    '''

    #Общее количество участников
    members_count = vk.groups.getById(group_id=group_id, fields=['members_count'])[0]['members_count']
    #Сдвиг
    offset = 0
    #Количество запросов методом execute
    request_number = members_count // exec_count if members_count % exec_count == 0 else members_count // exec_count + 1
    #Сюда складывать всё, что получаем
    result = []

    #ВкФункция для ускорения работы и уменьшения количества запросов
    #Из аргументов принимает ID группы, количество участников, текущий сдвиг и дополнительные поля
    vk_get_members = VkFunction(args=('group_id', 'members_count', 'offset', 'exec_count', 'fields'), code='''
                                        var members = [];
                                        var offset = 0;
                                        while ((offset < parseInt(%(exec_count)s)) && (offset + parseInt(%(offset)s) < parseInt(%(members_count)s))) {
                                            members = members + API.groups.getMembers({\'group_id\': %(group_id)s, \'v\': \'5.131\', \'count\': \'1000\', \'offset\': (%(offset)s + offset), 'fields': %(fields)s}).items;
                                            offset = offset + 1000;
                                        };
                                        return members;'''
                                  )
    #n раз сделать запрос, каждый раз увеличивать сдвиг
    for n in range(request_number):
        offset = exec_count * n
        result += vk_get_members(vk, group_id, members_count, offset, exec_count, fields)

    return result


def format_group_members(records, group_id):
    '''
    Приводит все записи к одному формату:\n
        добавляет два новых поля - age и education
        значения поля sex приведено к более читаемому виду (0,1,2 -> NaN, female, male)

    Аргументы:\n
        records -- список записей, обязательный параметр

    Возвращаемое значение:\n
        list of dicts\n
        Поля:\n
            age: возраст\n
            education: уровень образования\n
            city: город\n
            group: ID группы\n
            sex: пол

    '''

    result = []

    for record in records:
        record['age'] = get_age(record)
        record['education'] = get_education_level(record)
        record['city'] = record['city']['title'] if 'city' in record.keys() else None
        record['group'] = group_id
        #0 - NaN, 1 - female, 2 - male
        if record['sex'] == 0: record['sex'] = None
        elif record['sex'] == 1: record['sex'] = 'female'
        else: record['sex'] = 'male'
        result.append(trim_record(record))

    return result

def trim_record(record, fields = ('age', 'city', 'education', 'sex', 'group')):
    '''
    Возвращает новую запись, содержащую только релевантные поля в записи.
    Если такого поля запись не содержит, в него записывается None.

    Аргументы:
        record -- запись (dict), обязательный параметр\n
        fields -- поля, которые необходимо оставить, (по умолчанию: 'bdate', 'city', 'education', 'sex', 'group')

    Возвращаемое значение:\n
        dict\n
        Поля:\n
            указанные в fields


    '''

    #Нужные поля для анализа - это и есть параметр по умолчанию
    #Если решите добавить другие поля - я их не учитывал
    #Т.е. передавать параметр fields нужно только если вы сами напишете ещё функцию, которая эти поля будет анализировать
    return {key: record[key] if key in record.keys() else None  for key in fields}


def get_age(record, current_year = 2023):
    '''
    Возвращает возраст человека по дате рождения (если указана полностью)

    Аргументы:\n
        record -- запись (dict), обязательный параметр
        current_year -- текущий год (по умолчанию: 2023)

    Возвращаемое значение:\n
        Если есть дата рождения - int\n
        Если даты нет либо дата указана неверная - NaN

    '''

    if 'bdate' in record.keys() and record['bdate'].count('.') == 2:
        bdate = record['bdate']
        age = current_year - int(bdate[bdate.rfind('.') + 1:])
        #116 - самый старый человек на сегодняшний день, так что вполне справедливо можно не учитывать ничего больше
        #Лимит можно понизить, например, лет до 80 - вряд ли в ВК сидят люди такого возраста
        #Это ощутимо меняет выборку ("приколистов" с заоблачным возрастом очень много, как мне кажется)
        #Если снижать лимит - стоит также поменять верхнюю границу у возрастных групп, хотя на сами данные это не повлияет
        if age > 116: return None
        else: return age
    else:
        return None


def get_education_level(record):
    '''
    Вычисляет уровень образования по данным записи

    Аргументы:\n
        record -- запись (dict), обязательный параметр

    Возвращаемое значение:\n
        Указан ВУЗ и статус - статус\n
        Указан только ВУЗ - Higher (unspecified)\n
        Не указан ВУЗ:\n
            Возраст >=18: Secondary\n
            Возраст <18: Basic\n
            Возраст не указан: NaN

    '''

    higher_student = ['Undergraduate applicant', 'Student (Specialist)', 'Student (Bachelor\'s)', 'Student (Master\'s)']
    higher = ['Alumnus (Specialist)', 'Alumnus (Bachelor\'s)', 'Alumnus (Master\'s)', 'Postgraduate applicant']
    higher_super = ['Candidate of Sciences', 'PhD', 'Intern', 'Resident', 'Assistant', 'Doctoral student', 'Adjunct professor', 'Researcher', 'Postgraduate Student']

    if 'university' in record.keys():
        if 'education_status' in record.keys():
            if record['education_status'] in higher_student: return 'Higher (student)'
            if record['education_status'] in higher: return 'Higher'
            if record['education_status'] in higher_super: return 'Higher (highest qual)'
        else: return 'Higher (unspecified)'
    else:
        age = get_age(record)
        #СПОРНЫЙ МОМЕНТ
        #Если в профиле нет инфы о ВУЗе и человек старше 18 лет - я добавил ему СРЕДНЕЕ (Secondary) образование
        #Но это может попортить статистику, потому что далеко не все люди с ВЫСШИМ (Higher) образованием указали ВУЗ (перекос в сторону среднего)
        #Второй вариант - запрашивать данные о школах и проверять 11 классов, остальным - NaN, но тогда NaN будет очень много
        #Добавлю, если будет нужно
        if age is not None:
            if age >= 18: return 'Secondary'
            elif age >= 16:  return 'Basic'
            else: return 'Basic (student)'
        else:
            return None


def get_group_posts(vk, group_id, count = 1000):
    '''
    Возвращает список всех постов группы.

    Аргументы: \n
        vk_api -- VK API, vk_api.VkApi().getApi(), необходимый параметр\n
        group_id -- ID рассматриваемой группы, обязательный параметр\n
        count -- количество постов, запрашиваемых за один раз. НЕ БОЛЬШЕ 2500 (по умолчанию 1000), лучше не менять, большие посты могут вызвать ошибку: слишком большое тело запроса

    Возвращаемое значение:\n
        Список постов группы, формат - смотреть в документации ВК к API "Запись на стене"

    '''

    #Сдвиг
    offset = 0
    #Короткое имя
    domain = vk.groups.getById(group_id=group_id)[0]['screen_name']
    #Сюда складывать всё, что получаем
    result = []

    #ВкФункция для ускорения работы и уменьшения количества запросов
    #Из аргументов принимает ID группы, короткое имя, количество участников, текущий сдвиг
    vk_get_posts = VkFunction(args=('group_id', 'domain', 'count', 'offset'), code='''
                                        var posts = [];
                                        var offset = 0;
                                        while (offset < parseInt(%(count)s)) {
                                            posts = posts + API.wall.get({\'owner_id\': \'-\' + %(group_id)s, \'domain\': %(domain)s, \'v\': \'5.131\', \'filter\': \'owner\', \'count\': \'100\', \'offset\': (%(offset)s + offset)}).items;
                                            offset = offset + 100;
                                        };
                                        return posts;''')

    #Первый тестовый запрос
    posts_returned_count = len(vk.wall.get(owner_id='-' + group_id, domain=domain, offset=0, count=1, filter='owner')['items'])

    #Пока возвращается ненулевое количество постов, просим вернуть ещё
    new = []
    k = 0
    while posts_returned_count:
        try:
            result += new
            offset = count * k
            new = vk_get_posts(vk, group_id, domain, count, offset)
            posts_returned_count = len(new)
            k += 1
        except:
            return result

    return result


def format_group_posts(records):
    '''
    Приводит все записи к одному формату

    Аргументы:\n
        records: список записей, обязательный параметр

    Возвращаемое значение:\n
        python.list всех постов из группы\n
        Поля для каждого поста:\n
        -- id:  ID поста\n
        -- owner_id: ID автора поста\n
        -- date: дата публикации (unixtime)\n
        -- comments: числа комментариев\n
        -- likes: число лайков\n
        -- views: число просмотров\n

    '''

    result = []

    for record in records:
        record['comments'] = record['comments']['count']
        record['likes'] = record['likes']['count']
        record['reposts'] = record['reposts']['count']
        record['owner_id'] = record['owner_id'][1:]
        result.append(trim_record(record, fields = ['id', 'owner_id', 'date', 'comments', 'likes', 'reposts']))

    return result


#################################-----------------------------------------------------##################################
#################################################-----ANALYSIS-----#################################################
#################################-----------------------------------------------------##################################


def sex_stats_df(df):
    '''
    Возвраает pandas.DataFrame с основной статистикой по полу.


    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр

    Структура возвращаемого датафрейма:
        индексы -- total (количество), fraction (доля от общего)\n
        столбцы -- female, male

    '''
    #Количество ВСЕХ значений в колонке "sex", NaN не учитываются
    total = df['sex'].count()
    #Количество значений NaN в колонке "sex"
    total_unspecified = df['sex'].isna().sum()
    #Количество значений "male" и "female" в колонке "sex", соответственно
    total_male = df['sex'].value_counts()['male']
    total_female = df['sex'].value_counts()['female']
    #DataFrame в соответствии с заявленной структурой
    return pd.DataFrame({'female': {'total': total_female, 'fraction': total_female / total},
                        'male': {'total': total_male, 'fraction': total_male / total},
                        'unspecified': {'total': total_unspecified, 'fraction': total_unspecified / total}})

def age_stats_by_group_df(df, age_groups_bins = [0, 15, 18, 25, 35, 45, 55, 65, 117]):
    '''
    Возвраает pandas.DataFrame с основной статистикой по возрасту.

    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр

    Структура возвращаемого датафрейма:\n
        индексы -- возрастные группы\n
        столбцы -- size (всего), fraction (доля от общего), mean (среднее арифметическое), median (медиана)

    '''

    #Возраст по группам
    labels = [str(age_groups_bins[i - 1]) + '-' + str(age_groups_bins[i]) for i in range(1, len(age_groups_bins))]
    df['age_group'] = pd.cut(df['age'], bins=age_groups_bins, labels=labels)

    #Группировка по возрастым группам
    group = df.groupby('age_group')['age']

    #Новые столбцы
    res = group.size().to_frame('size').reindex()
    res['mean'] = group.mean()
    res['median'] = group.median()
    res['fraction'] = group.size() / group.size().sum()

    return res

def city_stats_df(df):
    """
    Возвращает датафрейм с основной статистикой по городам

    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр

    Структура возвращаемого датафрейма:\n
        индексы -- total (всего), fraction (доля от общего)\n
        столбцы -- города

    """

    stats = pd.concat([df["city"].value_counts(), df["city"].value_counts(normalize=True)], axis='columns').T
    stats.index = ['total', 'fraction']

    return stats

def education_stats_df(df):
    """
    Возвращает датафрейм с основной статистикой по образованию

    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр

    Структура возвращаемого датафрейма:\n
        индексы -- total (всего), fraction (доля от общего)\n
        столбцы -- уровни образования

    """

    stats = pd.concat([df["education"].value_counts(), df["education"].value_counts(normalize=True)], axis='columns').T
    stats.index = ['total', 'fraction']

    #Общее количество имеющих среднее (General) и высшее (Higher) образование
    higher_total = df[df['education'].isin(['Higher (unspecified)', 'Higher', 'Higher (student)', 'Higher (highest qual)'])].value_counts(dropna=False).sum()
    school_total = df[df['education'].isin(['Secondary', 'Basic'])].value_counts(dropna=False).sum()
    total = df['education'].count()
    stats['Higher (total)'] = [higher_total, higher_total / total]
    stats['General (total)'] = [school_total, school_total / total]

    return stats

def reactions_by_period_df(df, period='Y'):
    """
    Возвращает датафрейм с основной статистикой по реакциям

    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр\n
        period -- (Y) year, (M) month

    Структура возвращаемого датафрейма:\n
        индексы -- годы/месяцы\n
        столбцы -- likes, reposts, comments

    """

    return df.groupby(pd.to_datetime(df['date'], unit='s').dt.to_period(period))[['comments', 'likes', 'reposts']].sum()

def reactions_top_n_df(df, n=5, metric='likes'):
    '''
    Возвращает n самых популярных по metric постов

    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр\n
        n -- количество возвращаемых постов\n
        metric -- метрика (likes, reposts, comments)

    Структура возвращаемого датафрейма:\n
        индексы - посты\n
        столбцы -- ids, owner_ids, likes/comments/reposts

    '''

    res = df[['id', 'owner_id', metric]].sort_values(metric, ascending=False).head(n).reset_index(drop=True)
    res['link'] = 'https://vk.com/wall' + res['owner_id'].astype(str) + '_' + res['id'].astype(str)

    return res

def avg_group_member_df(df, age_groups_bins = [0, 15, 18, 25, 35, 45, 55, 65, 117], n = 1):
    """
    Возвращает датафрейм с портретом участника группы

    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр\n
        age_groups_bins -- границы возрастных групп (по умолчанию: [0, 15, 18, 25, 35, 45, 55, 65, 117])\n
            Пример:\n
            ['0-14', '15-17', '18-120'] <= [0, 15, 18, 120]\n
        n -- количество отображаемых групп (по умолчанию: 1)

    Структура возвращаемого датафрейма:\n
        столбцы -- sex, education, city (Series), age, count, fraction

    """

    #Возраст по группам
    labels = [str(age_groups_bins[i - 1]) + '-' + str(age_groups_bins[i]) for i in range(1, len(age_groups_bins))]
    df['age_group'] = pd.cut(df['age'], bins=age_groups_bins, labels=labels)

    #age заменяем на age_group и добавляем два новых поля - количество групп и долю от всех
    group = df.groupby(['sex', 'education', 'city', 'age_group'])
    res = group.size().nlargest(n).to_frame('size').reset_index()
    res['fraction'] = res['size'] / group.size().sum()

    return res

#################################-----------------------------------------------------##################################
#################################################-----VISUALIZATION-----#################################################
#################################-----------------------------------------------------##################################


def plot_sex_pie(dataframe):
    '''
    Строит круговую диаграмму полового состава

    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр

    '''

    df = sex_stats_df(dataframe)

    #Это те цвета, которые мне нравятся, но можете использовать любые
    #Порядок цветов - female, male, unspecified
    colors = ['#ff9999', '#66b3ff', '#808080']

    #Я подумал, что вы можете захотеть исключить из вывода тех, у кого пол не указан
    #В таком случае вместо CHANGE укажите unspecified
    exclude = "CHANGE"

    #Функция для автонаписания ярлыков
    def fmt(x):
        return '{:.1f}\n{:.0f}'.format(x, x*df.loc["total"].sum()/100)

    if df['unspecified'].values[0] == 0:
        exclude = 'unspecified'

    fig, ax = plt.subplots()
    ax.pie(df.loc["total", df.columns!=exclude].values, labels=df.loc["total", df.columns!=exclude].index.values,  autopct=fmt, colors=colors)
    #Название диаграммы
    ax.set(title='Group members by sex')

def plot_age_group_bar(dataframe, mode='size'):
    '''
    Строит столбчатую диаграму по возрастным группам

    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр\n
        mode -- значения, по которым строить диаграмму (size - количество, fraction - доля от всех, mean - ср. арифм., median - медиана)

    '''

    df = age_stats_by_group_df(dataframe)

    #Если диаграмма строится в режиме size или fraction - ширина у столбцов одинаковая
    #Если выбран другой режим - ширина тем больше, чем больший вес имеет эта возрастная группа среди всех
    #Если это не нужно - можно удалить и параметр width передавать статический, например, 0.5
    if mode in ['size', 'fraction']: width = 0.8
    else: width = [value / df['size'].sum() + 0.4 for value in df['size'].values]

    #Построение диаграммы
    fig, ax = plt.subplots()
    bar_container = ax.bar(df.index.values, df[mode].values, width=width)
    #Название диаграммы
    ax.set(ylabel=mode, title='Group members by age groups')
    #Ярлыки у столбцов - меняется вместе с режимом
    ax.bar_label(bar_container, labels=['{:.2f}'.format(value) for value in df[mode].values])

def plot_city_bar(dataframe, count=5, mode="total"):
    """
    Строит столбчатую диаграмму по городам

    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр\n
        count -- количество столбцов на диаграмме. Города, не вошедшие в это число, будут представлены вместе в столбце "Others"\n
        mode -- значения, по которым строить диаграмму (total - количество, fraction - доля от всех)

    """

    df = city_stats_df(dataframe)

    #Others - подпись для последнего столбца
    x = np.append(df.loc[mode].index.values[:count], 'Others')
    #Высота столбцов, высота последнего - сумма всех, не вошедших в count
    height = [value for value in df.loc[mode].values[:count]] + [sum(df.loc[mode].values[count:])]
    fig, ax = plt.subplots()
    #Поворот подписей, без него текст иногда накладывается друг на друга
    fig.autofmt_xdate()
    bar_container = ax.bar(x, height, width=0.5)
    #Название диаграммы
    ax.set(ylabel=mode, title='Group members by city')
    #Подписи к столбцам
    ax.bar_label(bar_container, labels=['{:.1f}'.format(value) for value in df.loc[mode].values[:count]] +  ['{:.1f}'.format(sum(df.loc[mode].values[count:]))])

def plot_education_bar(dataframe, mode='total', add=False):
    """
    Строит столбчатую диаграмму по уровням образования

    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр\n
        mode -- значения, по которым строить диаграмму (total - количество, fraction - доля от всех)\n
        add -- добавлять ли общее количество имеющих школьное и высшее образование (по умолчанию: False)

    """

    df = education_stats_df(dataframe)

    if not(add):
        df = df.drop(['Higher (total)', 'General (total)'], axis=1)

    #Построение диаграммы
    fig, ax = plt.subplots()
    bar_container = ax.bar(df.loc[mode].index.values, df.loc[mode].values, width=0.5)
    fig.autofmt_xdate()
    #Название диаграммы
    ax.set(ylabel=mode, title='Group members by education level')
    #Ярлыки у столбцов - меняется вместе с режимом
    ax.bar_label(bar_container, labels=['{:.1f}'.format(x) for x in df.loc[mode].values])

def plot_reactions_bar(dataframe, mode='likes', period='Y'):
    """
     Строит столбчатую диаграмму популярности постов по выбранному периоду по выбранной метрике

    Аргументы:\n
        df -- (pandas.DataFrame) -- DataFrame с данными, обязательный параметр\n
        mode -- метрика, по которым строить диаграмму (likes, reposts, comments) (по умолчанию: likes)\n
        period -- периоды, по которым строить диаграммы ((Y) year, (M) month) (по умолчанию: month)

    """

    df = reactions_by_period_df(dataframe, period)

    #Построение диаграммы
    fig, ax = plt.subplots()

    bar_container = ax.bar(df.index.to_timestamp(), df[mode].values, width=0.5 * (365 if period == 'Y' else 30))

    #Название диаграммы
    ax.set(ylabel=mode, title='{mode} by {period}'.format(mode=mode, period='year' if period == 'Y' else 'month'))

